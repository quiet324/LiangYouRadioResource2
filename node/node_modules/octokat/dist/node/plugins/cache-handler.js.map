{"version":3,"sources":["../../../src/plugins/cache-handler.js"],"names":["module","exports","_cachedETags","method","path","eTag","data","status","input","cb","clientOptions","headers","cacheHandler","get","request","jqXHR","ref","__IS_CACHED","Error","getResponseHeader","add"],"mappings":"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","file":"cache-handler.js","sourcesContent":["module.exports = new class CacheHandler {\n  constructor () {\n    this._cachedETags = {}\n  }\n\n  // Default cacheHandler methods\n  get (method, path) {\n    return this._cachedETags[`${method} ${path}`]\n  }\n\n  add (method, path, eTag, data, status) {\n    return this._cachedETags[`${method} ${path}`] = {eTag, data, status}\n  }\n\n  requestMiddlewareAsync (input, cb) {\n    let {clientOptions, method, path} = input\n    if (input.headers == null) { input.headers = {} }\n    let cacheHandler = clientOptions.cacheHandler || this\n    // Send the ETag if re-requesting a URL\n    if (cacheHandler.get(method, path)) {\n      input.headers['If-None-Match'] = cacheHandler.get(method, path).eTag\n    } else {\n      // The browser will sneak in a 'If-Modified-Since' header if the GET has been requested before\n      // but for some reason the cached response does not seem to be available\n      // in the jqXHR object.\n      // So, the first time a URL is requested set this date to 0 so we always get a response the 1st time\n      // a URL is requested.\n      input.headers['If-Modified-Since'] = 'Thu, 01 Jan 1970 00:00:00 GMT'\n    }\n\n    return cb(null, input)\n  }\n\n  responseMiddlewareAsync (input, cb) {\n    let {clientOptions, request, status, jqXHR, data} = input\n    if (!jqXHR) { return cb(null, input) } // The plugins are all used in `octo.parse()` which does not have a jqXHR\n\n    // Since this can be called via `octo.parse`, skip caching when there is no jqXHR\n    if (jqXHR) {\n      let {method, path} = request // This is also not defined when octo.parse is called\n\n      let cacheHandler = clientOptions.cacheHandler || this\n      if (status === 304 || status === 0) {\n        let ref = cacheHandler.get(method, path)\n        if (ref) {\n          var eTag;\n          ({data, status, eTag} = ref)\n          // Set a flag on the object so users know this is a cached response\n          data.__IS_CACHED = eTag || true\n        } else {\n          throw new Error(`ERROR: Bug in Octokat cacheHandler for path '${method} ${path}'. It had an eTag but not the cached response.`)\n        }\n      } else {\n        // Cache the response to reuse later\n        if (method === 'GET' && jqXHR.getResponseHeader('ETag')) {\n          var eTag = jqXHR.getResponseHeader('ETag')\n          cacheHandler.add(method, path, eTag, data, jqXHR.status)\n        }\n      }\n\n      input.data = data\n      input.status = status\n      return cb(null, input)\n    }\n  }\n}()\n"]}