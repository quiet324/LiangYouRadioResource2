{"version":3,"sources":["../../src/plus.js"],"names":["filter","require","forEach","map","onlyOnce","fn","Error","callFn","apply","arguments","plus","camelize","string","replace","m","toUpperCase","uncamelize","match","letter","toLowerCase","dasherize","slice","waterfall","tasks","cb","taskIndex","nextTask","val","length","taskCallback","err","task","extend","target","source","Object","keys","key","forOwn","obj","iterator","module","exports"],"mappings":"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","file":"plus.js","sourcesContent":["// Both of these internal methods are really small/simple and we are only\n// working with arrays anyway\nconst filter = require('lodash/_arrayFilter')\nconst forEach = require('lodash/_arrayEach')\nconst map = require('lodash/_arrayMap')\n\n// From async\nlet onlyOnce = fn =>\n  function () {\n    if (fn === null) { throw new Error('Callback was already called.') }\n    let callFn = fn\n    fn = null\n    return callFn.apply(this, arguments)\n  }\n\n// require('underscore-plus')\nlet plus = {\n  camelize (string) {\n    if (string) {\n      return string.replace(/[_-]+(\\w)/g, m => m[1].toUpperCase())\n    } else {\n      return ''\n    }\n  },\n\n  uncamelize (string) {\n    if (!string) { return '' }\n    return string.replace(/([A-Z])+/g, (match, letter = '') => `_${letter.toLowerCase()}`)\n  },\n\n  dasherize (string) {\n    if (!string) { return '' }\n\n    string = string[0].toLowerCase() + string.slice(1)\n    return string.replace(/([A-Z])|(_)/g, function (m, letter) {\n      if (letter) {\n        return `-${letter.toLowerCase()}`\n      } else {\n        return '-'\n      }\n    }\n    )\n  },\n\n  waterfall (tasks, cb) {\n    let taskIndex = 0\n    let nextTask = function (val) {\n      if (taskIndex === tasks.length) {\n        return cb(null, val)\n      }\n\n      let taskCallback = onlyOnce(function (err, val) {\n        if (err) { return cb(err, val) }\n        return nextTask(val)\n      })\n\n      let task = tasks[taskIndex++]\n      if (val) {\n        return task(val, taskCallback)\n      } else {\n        return task(taskCallback)\n      }\n    }\n\n    return nextTask(null) // Initial value passed to the 1st\n  },\n\n  // Just _.extend(target, source)\n  extend (target, source) {\n    if (source) {\n      return Object.keys(source).map((key) => {\n        target[key] = source[key]\n      })\n    }\n  },\n\n  // Just _.forOwn(obj, iterator)\n  forOwn (obj, iterator) {\n    return Object.keys(obj).map((key) =>\n      iterator(obj[key], key))\n  },\n\n  filter,\n  forEach,\n  map\n}\n\nmodule.exports = plus\n"]}