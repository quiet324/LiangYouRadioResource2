'use strict';

/* eslint-env mocha */
var _require = require('chai'),
    expect = _require.expect;

var _require2 = require('./test-config'),
    Octokat = _require2.Octokat,
    TOKEN = _require2.TOKEN,
    REPO_USER = _require2.REPO_USER,
    REPO_NAME = _require2.REPO_NAME;

describe('Event Emitter', function () {

  it('emits when a request begins and when it completes', function (done) {
    var emittedStart = false;
    // emittedEnd = false
    var emitter = function emitter(name, id, _ref, status, rate) {
      var method = _ref.method,
          path = _ref.path;

      expect(method).to.equal('GET');
      expect(path).to.be.a('string');
      switch (name) {
        case 'start':
          emittedStart = true;
          return emittedStart;
        case 'end':
          expect(emittedStart).to.be.true;
          expect(status).to.equal(200);
          expect(rate.remaining).to.be.gt(0);
          expect(rate.limit).to.be.gt(0);
          expect(rate.reset).to.be.gt(0);
          return done();
        default:
          return done('Woah! odd event name ' + name);
      }
    };

    var client = new Octokat({ token: TOKEN, emitter: emitter });
    client.repos(REPO_USER, REPO_NAME).fetch().then(function (info) {
      return expect(info).to.not.be.null;
    });

    // Mocha 3 does not like it when a promise is returned _and_ a done callback is expected
    return null;
  });

  it('emits unique end event IDs that were also emitted in a start event', function (done) {
    var ids = { start: [], end: [] };
    var emitter = function emitter(name, id) {
      ids[name].push(id);
      if (name === 'end') {
        // Make sure it previously appeared in a `start` event.
        expect(ids.start).to.include(id);
      }
      if (ids.end.length === 3) {
        // Make sure each `start` ID is unique.
        expect(ids.start[0]).to.not.equal(ids.start[1]);
        expect(ids.start[0]).to.not.equal(ids.start[2]);
        expect(ids.start[1]).to.not.equal(ids.start[2]);
        // Make sure each ID from a `start` event also had an `end` event.
        expect(ids.end).to.include(ids.start[0]);
        expect(ids.end).to.include(ids.start[1]);
        expect(ids.end).to.include(ids.start[2]);
        done();
      }
    };
    var client = new Octokat({ token: TOKEN, emitter: emitter });
    // Fire multiple concurrent requests to check their IDs
    client.repos(REPO_USER, REPO_NAME).fetch();
    client.repos(REPO_USER, REPO_NAME).fetch();
    client.repos(REPO_USER, REPO_NAME).fetch();
  });
});
//# sourceMappingURL=emitter.spec.js.map