'use strict';

/* eslint-env mocha */
var _require = require('chai'),
    expect = _require.expect;

var _require2 = require('../test-config'),
    client = _require2.client,
    LONG_TIMEOUT = _require2.LONG_TIMEOUT,
    test_repo = _require2.test_repo;

describe('Commits', function () {
  this.timeout(LONG_TIMEOUT);

  it('returns all commits', function () {
    return client.repos('sferik/rails_admin').commits.fetch().then(function (_ref) {
      var items = _ref.items;
      return expect(items[0].author).to.be.ok;
    });
  });

  // it "handles branch or sha argument", ->
  it('handles the sha option', function () {
    return client.repos('sferik/rails_admin').commits.fetch({ sha: 'master' });
  });

  it('returns all commits on the specified date', function () {
    return client.repos('sferik/rails_admin').commits.fetch({ since: '2011-01-20' }).then(function (_ref2) {
      var items = _ref2.items;
      return expect(items).to.be.an.Array;
    });
  });

  it('returns a commit', function () {
    return client.repos('sferik/rails_admin').commits('3cdfabd973bc3caac209cba903cfdb3bf6636bcd').fetch().then(function (commit) {
      return expect(commit.author.login).to.equal('caboteria');
    });
  });

  it('returns a detailed git commit', function () {
    return client.repos('octokit/octokit.rb').git.commits('2bfca14ed8ebc3dad75082ff175e6703aed7ccc0').fetch().then(function (commit) {
      return expect(commit.author.name).to.equal('Joey Wendt');
    });
  });

  it('creates a commit', function () {
    return client.repos(test_repo).commits.fetch().then(function (_ref3) {
      var items = _ref3.items;

      var lastCommit = items[items.length - 1];

      return client.repos(test_repo).git.commits.create({ message: 'My commit message', tree: lastCommit.commit.tree.sha, parents: [lastCommit.sha] });
    });
  });

  it('merges a branch into another', function () {
    var afterRemove = function afterRemove() {
      var repo = client.repos(test_repo);
      return repo.commits.fetch().then(function (_ref4) {
        var items = _ref4.items;

        var lastCommit = items[items.length - 1];
        return repo.git.refs.create({ ref: 'refs/heads/branch-to-merge', sha: lastCommit.sha }).then(function (v) {
          var head = 'master';
          var base = 'branch-to-merge';
          var commitMessage = 'Testing the merge API';
          return client.repos(test_repo).merges.create({ base: base, head: head, commitMessage: commitMessage });
        });
      });
    };

    return client.repos(test_repo).git.refs.heads('branch-to-merge').remove().then(afterRemove, afterRemove);
  });

  return it('returns a comparison', function () {
    return client.repos('gvaughn/octokit').compare('0e0d7ae299514da692eb1cab741562c253d44188', 'b7b37f75a80b8e84061cd45b246232ad958158f5').fetch().then(function (comparison) {
      expect(comparison.baseCommit.sha).to.equal('0e0d7ae299514da692eb1cab741562c253d44188');
      return expect(comparison.mergeBaseCommit.sha).to.equal('b7b37f75a80b8e84061cd45b246232ad958158f5');
    });
  });
});
//# sourceMappingURL=commits.spec.js.map