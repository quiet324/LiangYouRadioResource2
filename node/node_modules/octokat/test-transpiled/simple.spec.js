'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/* eslint-env mocha */
var _require = require('chai'),
    assert = _require.assert,
    expect = _require.expect;

var _require2 = require('./test-config'),
    Octokat = _require2.Octokat,
    client = _require2.client,
    USERNAME = _require2.USERNAME,
    ORG_NAME = _require2.ORG_NAME,
    REPO_USER = _require2.REPO_USER,
    REPO_NAME = _require2.REPO_NAME,
    OTHER_USERNAME = _require2.OTHER_USERNAME,
    LONG_TIMEOUT = _require2.LONG_TIMEOUT;

// NodeJS does not have a btoa


var btoa = null;

if (typeof window !== 'undefined' && window !== null) {
  btoa = window.btoa;
  // Use the `Buffer` if available (NodeJS)
} else if (typeof global !== 'undefined' && global !== null) {
  btoa = function base64encode(str) {
    var buffer = new global['Buffer'](str, 'binary');
    return buffer.toString('base64');
  };
} else {
  throw new Error('Native btoa function or Buffer is missing');
}

var trapFail = function trapFail(promise) {
  var onError = function onError(err) {
    console.error(JSON.stringify(err));
    return assert.catch(err);
  };
  // Depending on the Promise implementation the fail method could be:
  // - `.catch` (native Promise)
  // - `.fail` (jQuery or angularjs)
  promise.then(null, onError);
  return promise;
};

var GH = 'octo';
var REPO = 'myRepo';
var USER = 'someUser';
var ME = 'myUser';
// const BRANCH = 'BRANCH'
// let ANOTHER_USER = 'ANOTHER_USER'
var ORG = 'someOrg';
var GIST = 'someGist';
var ISSUE = 'someIssue';
// const COMMENT = 'someComment'

var STATE = {};

describe(GH + ' = new Octokat({token: ...})', function () {
  this.timeout(LONG_TIMEOUT);

  var stringifyAry = function stringifyAry(args) {
    if (!Array.isArray(args)) {
      args = [args];
    }
    if (!args.length) {
      return '';
    }
    var arr = args.map(function (arg) {
      return JSON.stringify(arg);
    });
    return arr.join(', ');
  };

  var itIs = function itIs(obj, msg, args, cb) {
    var code = '';
    var isFuncArgs = false;
    args.forEach(function (arg) {
      if (isFuncArgs) {
        code += '(' + stringifyAry(arg) + ')';
      } else {
        code += '.' + arg;
      }

      isFuncArgs = !isFuncArgs;
    });

    if (isFuncArgs) {
      code += '()';
    }

    var constructMethod = function constructMethod() {
      // Construct the method call
      var context = STATE[obj];
      isFuncArgs = false; // Every other arg is a function arg
      var finalArgs = [];
      args.forEach(function (arg) {
        var isLast = arg === args[args.length - 1];
        if (isFuncArgs) {
          if (!Array.isArray(arg)) {
            arg = [arg];
          }
          if (isLast) {
            finalArgs = arg;
          } else {
            context = context.apply(undefined, _toConsumableArray(arg));
          }
        } else {
          var names = arg.split('.');
          names.forEach(function (field) {
            context = context[field];
          });
        }

        isFuncArgs = !isFuncArgs;
      });

      return { finalArgs: finalArgs, context: context };
    };

    it('' + obj + code, function () {
      var _constructMethod = constructMethod(),
          finalArgs = _constructMethod.finalArgs,
          context = _constructMethod.context;
      // If the last arg was something like 'fetch' then


      if (isFuncArgs) {
        return context().then(cb);
      } else {
        return context.apply(undefined, _toConsumableArray(finalArgs)).then(cb);
      }
    });

    it('' + obj + code + ' (callback ver)', function () {
      var _constructMethod2 = constructMethod(),
          finalArgs = _constructMethod2.finalArgs,
          context = _constructMethod2.context;

      return context.apply(undefined, _toConsumableArray(finalArgs).concat([function (err, val) {
        if (err) {
          return assert.fail(err);
        }
        cb(val);
      }]));
    });
  };

  var itIsOk = function itIsOk(obj) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return itIs(obj, '', args, function (val) {
      return expect(val).to.be.ok;
    });
  };

  var itIsArray = function itIsArray(obj) {
    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    return itIs(obj, ' yields Array', args, function (val) {
      return expect(val).to.be.an.array;
    });
  };

  var itIsFalse = function itIsFalse(obj) {
    for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }

    return itIs(obj, ' yields False', args, function (val) {
      return expect(val).to.be.false;
    });
  };

  var itIsBoolean = function itIsBoolean(obj) {
    for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
      args[_key4 - 1] = arguments[_key4];
    }

    return itIs(obj, '', args, function (val) {
      return expect(val === true || val === false).to.be.true;
    });
  };

  before(function () {
    STATE[GH] = client;
  });

  describe('Synchronous methods', function () {
    it('supports octo.fromUrl(\'https://api.github.com/repos/' + REPO_USER + '/' + REPO_NAME + '\')', function () {
      return client.fromUrl('https://api.github.com/repos/' + REPO_USER + '/' + REPO_NAME).fetch().then(function (val) {
        return expect(val).to.not.be.null;
      });
    });

    it('supports octo.fromUrl(\'/repos/' + REPO_USER + '/' + REPO_NAME + '\')', function () {
      return client.fromUrl('/repos/' + REPO_USER + '/' + REPO_NAME).fetch().then(function (val) {
        return expect(val).to.not.be.null;
      });
    });
  });

  it('supports octo.parse(json)', function (done) {
    var json = {
      url: 'https://api.github.com/repos/philschatz/octokat.js',
      foo_url: 'http://philschatz.com',
      field: 'Hello there!',
      bar: {
        baz_url: 'http://philschatz.com'
      }
    };
    client.parse(json, function (err, ret) {
      expect(err).to.be.null;
      expect(ret.field).to.equal(json.field);
      expect(ret.url).to.equal(json.url);
      expect(ret.foo.url).to.equal(json.foo_url);
      // Make sure the parse recurses
      expect(ret.bar.baz.url).to.equal(json.bar.baz_url);
      // Make sure the obj was detected to be a repo
      expect(ret.fetch).to.not.be.null;
      expect(ret.issues).to.not.be.null;
      done();
    });
  });

  describe('Miscellaneous APIs', function () {
    itIsOk(GH, 'zen.read');
    itIsOk(GH, 'octocat.read');
    itIsOk(GH, 'octocat.read', { s: 'There is no need to be upset' });
    itIsOk(GH, 'emojis.fetch');
    itIsOk(GH, 'gitignore.templates.fetch');
    itIsOk(GH, 'gitignore.templates', 'C', 'read');
    // itIsOk(GH, 'markdown.create', [{text:'# Hello There'}, true])
    itIsOk(GH, 'meta.fetch');
    itIsOk(GH, 'rateLimit.fetch');
    itIsOk(GH, 'feeds.fetch');
  });

  itIsArray(GH, 'users.fetch');
  itIsArray(GH, 'gists.public.fetch');
  // itIsArray(GH, 'global.events')
  // itIsArray(GH, 'global.notifications')

  itIsArray(GH, 'search.repositories.fetch', { q: 'github' });
  // itIsArray(GH, 'search.code.fetch', {q:'github'})
  itIsArray(GH, 'search.issues.fetch', { q: 'github' });
  itIsArray(GH, 'search.users.fetch', { q: 'github' });

  itIsOk(GH, 'users', REPO_USER, 'fetch');
  itIsOk(GH, 'orgs', ORG_NAME, 'fetch');
  itIsOk(GH, 'repos', [REPO_USER, REPO_NAME], 'fetch');
  itIsArray(GH, 'issues.fetch');

  describe('Paged Results', function () {
    describe('Deprecated Notation', function () {
      it(GH + '.gists.public.fetch().then(results) -> results.nextPage()', function () {
        return trapFail(STATE[GH].gists.public.fetch()).then(function (_ref) {
          var nextPage = _ref.nextPage;
          return nextPage().then(function (_ref2) {
            var items = _ref2.items;

            expect(items).to.be.an('array');
            return expect(items).to.have.length.at.least(1);
          });
        });
      });

      it(GH + '.gists.public.fetch().then(results) -> results.prevPage()', function () {
        return trapFail(STATE[GH].gists.public.fetch()).then(function (_ref3) {
          var nextPage = _ref3.nextPage;
          return nextPage().then(function (_ref4) {
            var prevPage = _ref4.prevPage;
            return prevPage().then(function () {});
          });
        });
      });

      it(GH + '.gists.public.fetch().then(results) -> results.firstPage()', function () {
        return trapFail(STATE[GH].gists.public.fetch()).then(function (_ref5) {
          var nextPage = _ref5.nextPage;
          return nextPage().then(function (_ref6) {
            var firstPage = _ref6.firstPage;
            return firstPage().then(function () {});
          });
        });
      });

      it(GH + '.gists.public.fetch().then(results) -> results.lastPage()', function () {
        return trapFail(STATE[GH].gists.public.fetch()).then(function (_ref7) {
          var lastPage = _ref7.lastPage;
          return lastPage();
        });
      });
    });

    describe('New Notation', function () {
      it(GH + '.gists.public.fetch().then(results) -> results.nextPage.fetch()', function () {
        return trapFail(STATE[GH].gists.public.fetch()).then(function (_ref8) {
          var nextPage = _ref8.nextPage;
          return nextPage.fetch().then(function (_ref9) {
            var items = _ref9.items;

            expect(items).to.be.an('array');
            return expect(items).to.have.length.at.least(1);
          });
        });
      });

      it(GH + '.gists.public.fetch().then(results) -> results.prevPage.fetch()', function () {
        return trapFail(STATE[GH].gists.public.fetch()).then(function (_ref10) {
          var nextPage = _ref10.nextPage;
          return nextPage.fetch().then(function (_ref11) {
            var prevPage = _ref11.prevPage;
            return prevPage.fetch().then(function () {});
          });
        });
      });

      it(GH + '.gists.public.fetch().then(results) -> results.firstPage.fetch()', function () {
        return trapFail(STATE[GH].gists.public.fetch()).then(function (results) {
          return results.nextPage.fetch().then(function (moreResults) {
            return moreResults.firstPage.fetch().then(function () {});
          });
        });
      });

      it(GH + '.gists.public.fetch().then(results) -> results.lastPage.fetch()', function () {
        return trapFail(STATE[GH].gists.public.fetch()).then(function (results) {
          return results.lastPage.fetch();
        });
      });
    });
  });

  describe(REPO + ' = ' + GH + '.repos(OWNER, NAME)', function () {
    before(function () {
      STATE[REPO] = STATE[GH].repos(REPO_USER, REPO_NAME);
    });

    itIsOk(REPO, 'fetch');

    // Accessors for methods generated from URL patterns
    itIsArray(REPO, 'collaborators.fetch');
    itIsOk(REPO, 'readme.read');
    itIsArray(REPO, 'hooks.fetch');
    itIsArray(REPO, 'assignees.fetch');
    itIsArray(REPO, 'languages.fetch');
    itIsArray(REPO, 'teams.fetch');
    itIsArray(REPO, 'tags.fetch');
    itIsArray(REPO, 'branches.fetch');
    itIsArray(REPO, 'contributors.fetch');
    itIsArray(REPO, 'subscribers.fetch');
    itIsArray(REPO, 'subscription.fetch');
    itIsArray(REPO, 'comments.fetch');
    itIsArray(REPO, 'downloads.fetch');
    itIsArray(REPO, 'milestones.fetch');
    itIsArray(REPO, 'labels.fetch');
    itIsArray(REPO, 'stargazers.fetch');
    itIsArray(REPO, 'forks.fetch');

    it('camelCases URL fields that are not templated (ie ' + REPO + '.htmlUrl)', function () {
      return STATE[REPO].fetch().then(function (repo) {
        return expect(repo.htmlUrl).to.be.a('string');
      });
    });

    describe(REPO + '.issues...', function () {
      itIsArray(REPO, 'issues.fetch');
      itIsArray(REPO, 'issues.events.fetch');
      itIsArray(REPO, 'issues.comments.fetch');
      // itIsArray(REPO, 'issues.comments', commentId, 'fetch')

      itIsOk(REPO, 'issues.create', { title: 'Test Issue' });
      itIsOk(REPO, 'issues', 1, 'fetch');
    });

    // itIsOk(REPO, 'pages.fetch')
    // itIsOk(REPO, 'pages.builds.fetch')
    // itIsOk(REPO, 'pages.builds.latest.fetch')

    describe(REPO + '.stats...', function () {
      itIsOk(REPO, 'stats.contributors.fetch');
      itIsOk(REPO, 'stats.commitActivity.fetch');
      // itIsOk(REPO, 'stats.codeFrequency.fetch') Commented because it seems to always return 403
      itIsOk(REPO, 'stats.participation.fetch');
      itIsOk(REPO, 'stats.punchCard.fetch');
    });

    describe(REPO + '.git... (Git Data)', function () {
      itIsArray(REPO, 'git.refs.fetch');
      // itIsArray(REPO, 'git.refs.tags.fetch')    This repo does not have any tags: TODO: create a tag
      itIsArray(REPO, 'git.refs.heads.fetch');

      // itIsOk(REPO, 'git.tags.create', {tag:'test-tag', message:'Test tag for units', ...})
      // itIsOk(REPO, 'git.tags.one', 'test-tag')
      itIsOk(REPO, 'git.trees', 'c18ba7dc333132c035a980153eb520db6e813d57', 'fetch');
      // itIsOk(REPO, 'git.trees.create', {tree: [sha], base_tree: sha})

      it('.git.refs.tags.fetch()', function () {
        return STATE[GH].repos('philschatz', 'octokat.js').git.refs.tags.fetch().then(function (_ref12) {
          var items = _ref12.items;

          expect(items).to.be.a('array');
          return expect(items.length).to.equal(17);
        });
      });

      it('.git.refs.tags("v0.1.1").fetch()', function () {
        return STATE[GH].repos('philschatz', 'octokat.js').git.refs.tags('v0.1.1').fetch().then(function (tag) {
          return expect(tag).to.be.a('object');
        });
      });

      it('.git.refs("any/path").fetch() like pull/2/head refs on github', function () {
        return STATE[GH].repos('philschatz', 'octokat.js').git.refs('pull/2/head').fetch().then(function (pullRef) {
          return expect(pullRef).to.be.a('object');
        });
      });

      it('.git.blobs.create("Hello")   and .blobs(sha).read()', function () {
        return STATE[REPO].git.blobs.create({ content: 'Hello', encoding: 'utf-8' }).then(function (_ref13) {
          var sha = _ref13.sha;

          expect(sha).to.be.ok;
          return STATE[REPO].git.blobs(sha).read().then(function (v) {
            return expect(v).to.equal('Hello');
          });
        });
      });

      it('.git.blobs.create(...) and .blobs(...).readBinary()', function () {
        return STATE[REPO].git.blobs.create({ content: btoa('Hello'), encoding: 'base64' }).then(function (_ref14) {
          var sha = _ref14.sha;

          expect(sha).to.be.ok;
          return STATE[REPO].git.blobs(sha).readBinary().then(function (v) {
            return expect(v).to.have.string('Hello');
          });
        });
      });
    });

    // Make sure the library does not just ignore the isBase64 flag
    // TODO: This is commented because caching is only based on the path, not the flags (or the verb)
    // STATE[REPO].git.blobs.one(sha)
    // .then (v) ->
    //   expect(v).to.not.have.string('Hello')

    describe('Collaborator changes', function () {
      it('gets a list of collaborators', function () {
        return trapFail(STATE[REPO].collaborators.fetch()).then(function (v) {
          return expect(v).to.be.an.array;
        });
      });

      it('tests membership', function () {
        return trapFail(STATE[REPO].collaborators.contains(REPO_USER)).then(function (v) {
          return expect(v).to.be.true;
        });
      });

      return it('adds and removes a collaborator', function () {
        return trapFail(STATE[REPO].collaborators(OTHER_USERNAME).add()).then(function (v) {
          expect(v).to.be.ok;
          return trapFail(STATE[REPO].collaborators(OTHER_USERNAME).remove()).then(function (v) {
            return expect(v).to.be.true;
          });
        });
      });
    });
  });

  describe(USER + ' = ' + GH + '.users(USERNAME)', function () {
    before(function () {
      STATE[USER] = STATE[GH].users(USERNAME);
    });

    itIsOk(USER, 'fetch');
    itIsArray(USER, 'repos.fetch');
    itIsArray(USER, 'orgs.fetch');
    itIsArray(USER, 'gists.fetch');
    itIsArray(USER, 'followers.fetch');
    itIsArray(USER, 'following.fetch');
    itIsFalse(USER, 'following.contains', 'defunkt');
    itIsArray(USER, 'keys.fetch');
    itIsArray(USER, 'events.fetch');
    itIsArray(USER, 'receivedEvents.fetch');
    itIsArray(USER, 'starred.fetch');

    return it('camelCases URL fields that are not templated (ie ' + USER + '.avatarUrl)', function () {
      return STATE[USER].fetch().then(function (repo) {
        expect(repo.htmlUrl).to.be.a('string');
        return expect(repo.avatarUrl).to.be.a('string');
      });
    });
  });

  describe(ORG + ' = ' + GH + '.orgs(ORG_NAME)', function () {
    before(function () {
      STATE[ORG] = STATE[GH].orgs(ORG_NAME);
    });

    itIsArray(ORG, 'fetch');
    itIsArray(ORG, 'members.fetch');
    itIsArray(ORG, 'repos.fetch');
    return itIsArray(ORG, 'issues.fetch');
  });

  describe(ME + ' = ' + GH + '.me (the authenticated user)', function () {
    before(function () {
      STATE[ME] = STATE[GH].me;
    });

    // itIsOk(ME, 'fetch')

    itIsArray(ME, 'repos.fetch');
    itIsArray(ME, 'orgs.fetch');
    itIsArray(ME, 'followers.fetch');
    itIsArray(ME, 'following.fetch');
    itIsFalse(ME, 'following.contains', 'defunkt');
    itIsArray(ME, 'emails.fetch');
    itIsFalse(ME, 'emails.contains', 'invalid@email.com');
    // itIsArray(ME, 'keys.all')
    // itIsFalse(ME, 'keys.is', 'invalid-key')

    itIsArray(ME, 'issues.fetch');

    itIsArray(ME, 'starred.fetch');
    itIsBoolean(ME, 'starred.contains', 'philschatz/octokat.js');

    describe('Multistep operations', function () {
      return it('.starred.add(OWNER, REPO), .starred.is(...), and then .starred.remove(...)', function () {
        return trapFail(STATE[ME].starred(REPO_USER, REPO_NAME).add()).then(function () {
          return STATE[ME].starred.contains(REPO_USER, REPO_NAME).then(function (isStarred) {
            expect(isStarred).to.be.true;
            return STATE[ME].starred(REPO_USER, REPO_NAME).remove().then(function (v) {
              return expect(v).to.be.true;
            });
          });
        });
      });
    });
  });

  describe(GIST + ' = ' + GH + '.gist(GIST_ID)', function () {
    before(function () {
      // Create a Test Gist for all the tests
      var config = {
        description: 'Test Gist',
        'public': false,
        files: {
          'hello.txt': {
            content: 'Hello World'
          }
        }
      };

      return STATE[GH].gists.create(config).then(function (gist) {
        STATE[GIST] = gist;
      });
    });

    // itIsOk(GIST, 'fetch')

    // itIsArray(GIST, 'forks.all')

    // TODO: For some reason this test fails in the browser. Probably POST vs PUT?
    return it('can be .starred.add() and .starred.remove()', function () {
      return STATE[GIST].star.add().then(function () {
        return STATE[GIST].star.remove();
      });
    });
  });

  return describe(ISSUE + ' = ' + REPO + '.issues(1)', function () {
    before(function () {
      STATE[ISSUE] = STATE[REPO].issues(1);
    });

    itIsOk(ISSUE, 'fetch');
    itIsOk(ISSUE, 'update', { title: 'New Title', state: 'closed' });

    return describe('Comment methods (Some are on the repo, issue, or comment)', function () {
      itIsArray(ISSUE, 'comments.fetch');
      itIsOk(ISSUE, 'comments.create', { body: 'Test comment' });
      // NOTE: Comment updating is awkward because it's on the repo, not a specific issue.
      // itIsOk(REPO, 'issues.comments.update', 43218269, {body: 'Test comment updated'})
      return itIsOk(REPO, 'issues.comments', 43218269, 'fetch');
    });
  });
});

// Deprecated. Now provides only `issueUrl`
// it 'comment.issue()', ->
//   trapFail STATE[REPO].issues.comments(43218269).fetch()
//   .then (comment) ->
//     comment.issue()

// TODO: Refactor: put this back in once the constructor allows setting plugins
// describe 'Allows disabling hypermedia conversion', () ->
//   it 'returns a simple JSON object when fetching a repository', ->
//     client = new Octokat({token: TOKEN, disableHypermedia: true})
//     client.repos(REPO_USER, REPO_NAME).fetch()
//     .then (repo) ->
//       expect(repo.full_name).to.not.be.null
//       expect(repo.html_url).to.not.be.null
//       expect(repo.created_at).to.be.a('string')
//       # Serializing the object as JSON should work
//       JSON.stringify(repo)

describe('Cache Handler', function () {
  return it('is called when refetching a URL', function () {
    var retreivedFromCache = false;
    var cacheHandler = new (function () {
      function CacheHandler() {
        _classCallCheck(this, CacheHandler);

        this._cachedETags = {};
      }

      _createClass(CacheHandler, [{
        key: 'get',
        value: function get(method, path) {
          retreivedFromCache = !!this._cachedETags[method + ' ' + path];
          return this._cachedETags[method + ' ' + path];
        }
      }, {
        key: 'add',
        value: function add(method, path, eTag, data, status) {
          this._cachedETags[method + ' ' + path] = { eTag: eTag, data: data, status: status };
        }
      }]);

      return CacheHandler;
    }())();

    var client2 = new Octokat({ cacheHandler: cacheHandler });
    return client2.repos(REPO_USER, REPO_NAME).fetch().then(function (repo1) {
      return client2.repos(REPO_USER, REPO_NAME).fetch().then(function (repo2) {
        expect(JSON.stringify(repo1) === JSON.stringify(repo2)).to.be.true;
        return expect(retreivedFromCache).to.be.true;
      });
    });
  });
});
//# sourceMappingURL=simple.spec.js.map